
# 组件化

所谓组件化就是将页面拆分成一个个的单元，并且是可以复用的，且带有一个名字，其中组件化最核心的问题是组件之间的通信，下面将介绍几种组件通信的方式。

## 第一种父组件与自组件通信 ———— props

props是在子组件中定义的一个选项，可将父组件中的数据通过定义的props传递到子组件中，它拥有的类型如下所示：

``` javascript
Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
```

### 代码演示(假设在同一目录下)：

子组件定义：

``` html
<template>
    <ul>
        <li v-for='item in list'>{{item}}</li>
    </ul>
</template>
<script>
    export default {
        props:{
            list:{
                type:Array,
                require:true,
                default(){
                    return []
                }
            }
        }
    }
</script>
```

父组件应用：

``` html
<template>
    <div>
        <todo-list :list='list'></todo-list>
    </div>
</template>
<script>
    import todoList from './todoList.vue'
    export default {
        data() {
            return {
                list: [1,2,3,4]
            }
        },
        components:{
            todoList
        }
    }
</script>
```

## 第二种子组件与父组件通信 ———— $emit

子组件与父组件通信是通过在子组件中使用$emit触发某个事件并传递参数（根据需要可传可不传），并在父组件中通过指令v-on:eventname（或者@:eventname）绑定事件并接受参数来实现的。

### 代码演示(假设在同一目录下)：

子组件定义：

``` html
<template>
    <div>
        <button @click='clickMe'>clickme</button>
    </div>
</template>
<script>
    export default {
        methods:{
            clickMe(){
                this.$emit('clickMe','我是从子组件c-button传递过来的')
            }
        }
    }
</script>
```

父组件应用：

``` html
<template>
    <div>
        <v-button @clickMe='onClick'></v-button>
    </div>
</template>
<script>
    import vButton from './vButton.vue'
    export default {
        components:{
            vButton
        },
        methods:{
            onClick(fromSon){
                console.log(fromSon);
            }
        }
    }
</script>
```

## 第三种provide与inject实现通信

这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。

在有些情况下需要根组件与多级子组件共享数据，如果使用props进行组件直接传值会相当麻烦，此时可以通过在父组件中定义provide选项定义需要共享的数据，在子组件中通过inject注入数据，这样就可以拿到父级组件共享的数据！但provide中共享的数据不是响应式的，如果需要做响应式，可以使用2.6最新API Vue.observable 优化响应式 provide(推荐)

provide可以是对象也可以是返回对象的函数，inject可以是一个字符串数组或者对象。

### 代码演示(假设在同一目录下)：

子组件定义：

``` html
<template>
    <div>
        <button @click='clickMe'>clickme</button>
    </div>
</template>
<script>
    export default {
        inject:['a'],
        methods:{
            clickMe(){
                console.log(this.a);
            }
        }
    }
</script>
```

父组件应用：

``` html
<template>
    <div>
        <v-button></v-button>
    </div>
</template>
<script>
    import vButton from './vButton.vue'
    export default {
        provide:{
            return {
                a:'我是通过provide向子组件传递的值'
            }
        },
        components:{
            vButton
        }
    }
</script>
```

## 第四种使用$attrs和$listeners实现通信

    官网描述：

    $attrs是指包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。
    当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，
    并且可以通过 v-bind="$attrs" 传入内部组件——在创建高级别的组件时非常有用

    $listeners是指包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。
    它可以通过 v-on="$listeners" 传入内部组件——在创建更高层次的组件时非常有用。

    这里意思是$attrs表示的是子组件所有的非props属性，在子组件中可通过this.$attrs获取。

    默认情况下$attrs中的属性都是添加在子组件的包裹元素上，可以通过在子组件中设置选项inheritAttrs
    的值为false，可以取消该默认行为。

    $listeners是指绑定在子组件上所有的事件，在子组件中可通过this.$listeners获取。

    有时候在父作用域中给子组件添加事件，会发现添加的事件不生效，比如click事件，要想使事件能执行，
    需要在子组件中触发click事件，如果不触发事件，咱们也可通过修饰符达到该效果。通过修饰符添加的
    事件是绑定在子组件的根元素上的。

### 代码演示(假设在同一目录下)：

子组件定义：

``` html
<template>
    <div>
        <button 
            v-bind='$attrs' 
            v-on='$listeners'>clickme</button>
    </div>
</template>
<script>
    export default {
        created(){
            console.log(this.$attrs) // 打印 { a:'a', b:'b', c:'c'}
            console.log(this.$listeners) // 打印 { a: 'clicka', b: 'clickb', c:'clickc'}
        }
    }
</script>
```

父组件应用：

``` html
<template>
    <div>
        <v-button 
            a='a' 
            b='b' 
            c='c' 
            @a='clicka' 
            @b='clickc' 
            @c='clickc'
            @click.native='clickNative'></v-button>
    </div>
</template>
<script>
    import vButton from './vButton.vue'
    export default {
        methods:{
            clicka(){
                console.log('a')
            },
            clickb(){
                console.log('b')
            },
            clickc(){
                console.log('c')
            }
        },
        components:{
            vButton
        }
    }
</script>
```

## 第五种使用事件总线机制实现通信

该种方式可以实现父子组件间、兄弟组件之间相互通信，但项目数据共享过于复杂不太适合使用事件总线机制。

所谓事件总线机制无非就是通过实例化一个vue实例，将该vue实例作为一个中转站来进行通信，具体是通过vue
实例的$emit以及$on方法来实现的。

### 代码演示(假设在同一目录下)：

Vue项目中的main.js部分代码

``` javascript
import Vue from 'vue';
let bus = new Vue();
Vue.prototype.$bus = bus;


```

子组件A定义：

``` html
<template>
    <div>
        <button @click='sendData'>clickme</button>
    </div>
</template>
<script>
    export default {
        data() {
            return {
                a:''
            }
        },
        methods:{
            sendData(){
                this.$bus.$emit('fromA','我是来自a组件的数据')
            }
        },
        mounted(){
            this.$bus.$on('fromParent',res => {
                this.a = res; // 会接收来自父组件的数据
            })
        }
    }
</script>
```

子组件B定义：

``` html
<template>
    <div>
        <button>clickme</button>
    </div>
</template>
<script>
    export default {
        data() {
            return {
                B:''
            }
        },
        mounted(){
            this.$bus.$on('fromA',res => {
                this.B = res; // 接受来自A组件的数据，B与A是兄弟组件
            })
        }
    }
</script>
```
父组件应用：

``` html
<template>
    <div>
        <a></a>
        <b></b>
    </div>
</template>
<script>
    import A from './A.vue';
    import B from 'B.vue';
    export default {
        mounted(){
            this.$bus.$emit('fromParent','我是来自父组件的数据')
        },
        components:{
            A,B
        }
    }
</script>
```

## 第六种方式发布订阅者模式进行通信

所谓发布订阅者其实是程序设计中的一种设计模式，Vue的$on和$emit其本质也是基于这种模式实现的。
该方式也能实现父子组件、兄弟组件之间通信。

### 代码演示(假设在同一目录下)：

Vue项目中的main.js部分代码

``` javascript
import Vue from 'vue';

class Bus {
    constructor(){
        this.callbacks = {};
    }

    $on(name, fn){
        this.callbacks[name] = this.callbacks[name] || [];
        this.callbacks[name].push(fn);
    }

    $emit(name, data){
        if(this.callbacks[name]){
            this.callbacks[name].forEach(fn => {
                fn && fn(data);
            })
        }
    }
}

Vue.prototype.$bus = new Bus();
```

子组件定义：

``` html
<template>
    <div>{{fromBus}}</div>
</template>
<script>
export default {
    data() {
        return {
            fromBus:''
        }
    },
    mounted(){
        this.$bus.$on('fromParent',res => {
            this.fromBus = res; // 接受来自父组件的数据
        })
    }
}
</script>
```

父组件应用：

``` html
<template>
    <div>
        <child></child>
    </div>
</template>
<script>
import child from 'child.vue';
export default {
    mounted(){
        this.$bus.$emit('fromParent','我是来自父组件的数据');
    },
    components:{
        child
    }
}
</script>
```

## 第七种通信方式$children、$parent

常规方式通信（除了事件总线外）是无法做到兄弟组件之间相互通信的，我们可以通过$parent间接实现兄弟组件之间通信。

### 代码演示(假设在同一目录下)：

$parent方式：

子组件A定义：

```html
<template>
    <div>
        我是组件A
    </div>
</template>
<script>
export default {
    mounted(){
        this.$parent.$on('onCompB',(res) => {
            console.log('监听来自组件B的事件并接受参数',res)
        })
        this.$parent.$emit('onCompA', "触发onCompA事件，与B组件通信")
    }
}
</script>
```

子组件B定义：

```html
<template>
    <div>
        我是组件B
    </div>
</template>
<script>
export default {
    mounted(){
        this.$parent.$on('onCompA',(res) => {
            console.log('监听来自组件A的事件并接受参数',res)
        })
        this.$parent.$emit('onCompB', "触发onCompB事件，与A组件通信")
    }
}
</script>
```

父组件定义：

```html
<template>
    <div>
        <A></A>
        <B></B>
    </div>
</template>

<script>
import A from "./A";
import B from "./B";
export default {
    components:{
        A,
        B
    }
}
</script>
```

$parent、$children实现向下或向上单向通信：

首先需要创建一个js文件，如index.js，内容如下：

```javascript
// 由于vue2.0中的$dispatch已废弃，可结合this.$parent自定义$boradcast，向上通知
export function $dispatch (eventName, data) {
    let parent = this.$parent;
    while (parent) {
        parent.$emit(eventName, data);
        parent = parent.$parent;
    }
}

function boradcast (eventName, data) {
    let children = this.$children;
    children.forEach(child => {
        child.$emit(eventName, data);
        if (child.$children.length) {
            boradcast.call(child, eventName, data);
        }
    });
}

// 由于vue2.0中的$broadcast已废弃，可结合this.$children自定义$boradcast，向下广播
export function $boradcast (eventName, data) {
    boradcast.call(this, eventName, data);
}
```